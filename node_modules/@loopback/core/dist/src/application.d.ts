import { Binding, Constructor, Context } from '@loopback/context';
import { Component } from './component';
import { Server } from './server';
/**
 * Application is the container for various types of artifacts, such as
 * components, servers, controllers, repositories, datasources, connectors,
 * and models.
 */
export declare class Application extends Context {
    options: ApplicationConfig;
    constructor(options?: ApplicationConfig);
    /**
     * Register a controller class with this application.
     *
     * @param controllerCtor {Function} The controller class
     * (constructor function).
     * @param {string=} name Optional controller name, default to the class name
     * @return {Binding} The newly created binding, you can use the reference to
     * further modify the binding, e.g. lock the value to prevent further
     * modifications.
     *
     * ```ts
     * class MyController {
     * }
     * app.controller(MyController).lock();
     * ```
     */
    controller(controllerCtor: ControllerClass, name?: string): Binding;
    /**
     * Bind a Server constructor to the Application's master context.
     * Each server constructor added in this way must provide a unique prefix
     * to prevent binding overlap.
     *
     * ```ts
     * app.server(RestServer);
     * // This server constructor will be bound under "servers.RestServer".
     * app.server(RestServer, "v1API");
     * // This server instance will be bound under "servers.v1API".
     * ```
     *
     * @param {Constructor<Server>} server The server constructor.
     * @param {string=} name Optional override for key name.
     * @returns {Binding} Binding for the server class
     * @memberof Application
     */
    server<T extends Server>(ctor: Constructor<T>, name?: string): Binding<T>;
    /**
     * Bind an array of Server constructors to the Application's master
     * context.
     * Each server added in this way will automatically be named based on the
     * class constructor name with the "servers." prefix.
     *
     * If you wish to control the binding keys for particular server instances,
     * use the app.server function instead.
     * ```ts
     * app.servers([
     *  RestServer,
     *  GRPCServer,
     * ]);
     * // Creates a binding for "servers.RestServer" and a binding for
     * // "servers.GRPCServer";
     * ```
     *
     * @param {Constructor<Server>[]} ctors An array of Server constructors.
     * @returns {Binding[]} An array of bindings for the registered server classes
     * @memberof Application
     */
    servers<T extends Server>(ctors: Constructor<T>[]): Binding[];
    /**
     * Retrieve the singleton instance for a bound constructor.
     *
     * @template T
     * @param {Constructor<T>=} ctor The constructor that was used to make the
     * binding.
     * @returns {Promise<T>}
     * @memberof Application
     */
    getServer<T extends Server>(target: Constructor<T> | String): Promise<T>;
    /**
     * Start the application, and all of its registered servers.
     *
     * @returns {Promise}
     * @memberof Application
     */
    start(): Promise<void>;
    /**
     * Stop the application instance and all of its registered servers.
     * @returns {Promise}
     * @memberof Application
     */
    stop(): Promise<void>;
    /**
     * Helper function for iterating across all registered server components.
     * @protected
     * @template T
     * @param {(s: Server) => Promise<T>} fn The function to run against all
     * registered servers
     * @memberof Application
     */
    protected _forEachServer<T>(fn: (s: Server) => Promise<T>): Promise<void>;
    /**
     * Add a component to this application and register extensions such as
     * controllers, providers, and servers from the component.
     *
     * @param componentCtor The component class to add.
     * @param {string=} name Optional component name, default to the class name
     *
     * ```ts
     *
     * export class ProductComponent {
     *   controllers = [ProductController];
     *   repositories = [ProductRepo, UserRepo];
     *   providers = {
     *     [AUTHENTICATION_STRATEGY]: AuthStrategy,
     *     [AUTHORIZATION_ROLE]: Role,
     *   };
     * };
     *
     * app.component(ProductComponent);
     * ```
     */
    component(componentCtor: Constructor<Component>, name?: string): Binding<any>;
    /**
     * Set application metadata. `@loopback/boot` calls this method to populate
     * the metadata from `package.json`.
     *
     * @param metadata Application metadata
     */
    setMetadata(metadata: ApplicationMetadata): void;
}
/**
 * Configuration for application
 */
export interface ApplicationConfig {
    /**
     * Other properties
     */
    [prop: string]: any;
}
export declare type ControllerClass = Constructor<any>;
/**
 * Type definition for JSON
 */
export declare type JSONPrimitive = string | number | boolean | null;
export declare type JSONValue = JSONPrimitive | JSONObject | JSONArray;
export interface JSONObject {
    [property: string]: JSONValue;
}
export interface JSONArray extends Array<JSONValue> {
}
/**
 * Type description for `package.json`
 */
export interface ApplicationMetadata extends JSONObject {
    name: string;
    version: string;
    description: string;
}
