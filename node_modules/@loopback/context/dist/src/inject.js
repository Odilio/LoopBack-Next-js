"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/context
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const metadata_1 = require("@loopback/metadata");
const value_promise_1 = require("./value-promise");
const resolution_session_1 = require("./resolution-session");
const PARAMETERS_KEY = metadata_1.MetadataAccessor.create('inject:parameters');
const PROPERTIES_KEY = metadata_1.MetadataAccessor.create('inject:properties');
/**
 * A decorator to annotate method arguments for automatic injection
 * by LoopBack IoC container.
 *
 * Usage - Typescript:
 *
 * ```ts
 * class InfoController {
 *   @inject('authentication.user') public userName: string;
 *
 *   constructor(@inject('application.name') public appName: string) {
 *   }
 *   // ...
 * }
 * ```
 *
 * Usage - JavaScript:
 *
 *  - TODO(bajtos)
 *
 * @param bindingKey What binding to use in order to resolve the value of the
 * decorated constructor parameter or property.
 * @param metadata Optional metadata to help the injection
 * @param resolve Optional function to resolve the injection
 *
 */
function inject(bindingKey, metadata, resolve) {
    metadata = Object.assign({ decorator: '@inject' }, metadata);
    return function markParameterOrPropertyAsInjected(target, member, methodDescriptorOrParameterIndex) {
        if (typeof methodDescriptorOrParameterIndex === 'number') {
            // The decorator is applied to a method parameter
            // Please note propertyKey is `undefined` for constructor
            const paramDecorator = metadata_1.ParameterDecoratorFactory.createDecorator(PARAMETERS_KEY, {
                target,
                member,
                methodDescriptorOrParameterIndex,
                bindingKey,
                metadata,
                resolve,
            }, 
            // Do not deep clone the spec as only metadata is mutable and it's
            // shallowly cloned
            { cloneInputSpec: false });
            paramDecorator(target, member, methodDescriptorOrParameterIndex);
        }
        else if (member) {
            // Property or method
            if (target instanceof Function) {
                throw new Error('@inject is not supported for a static property: ' +
                    metadata_1.DecoratorFactory.getTargetName(target, member));
            }
            if (methodDescriptorOrParameterIndex) {
                // Method
                throw new Error('@inject cannot be used on a method: ' +
                    metadata_1.DecoratorFactory.getTargetName(target, member, methodDescriptorOrParameterIndex));
            }
            const propDecorator = metadata_1.PropertyDecoratorFactory.createDecorator(PROPERTIES_KEY, {
                target,
                member,
                methodDescriptorOrParameterIndex,
                bindingKey,
                metadata,
                resolve,
            }, 
            // Do not deep clone the spec as only metadata is mutable and it's
            // shallowly cloned
            { cloneInputSpec: false });
            propDecorator(target, member);
        }
        else {
            // It won't happen here as `@inject` is not compatible with ClassDecorator
            /* istanbul ignore next */
            throw new Error('@inject can only be used on a property or a method parameter');
        }
    };
}
exports.inject = inject;
var Getter;
(function (Getter) {
    /**
     * Convert a value into a Getter returning that value.
     * @param value
     */
    function fromValue(value) {
        return () => Promise.resolve(value);
    }
    Getter.fromValue = fromValue;
})(Getter = exports.Getter || (exports.Getter = {}));
(function (inject) {
    /**
     * Inject a function for getting the actual bound value.
     *
     * This is useful when implementing Actions, where
     * the action is instantiated for Sequence constructor, but some
     * of action's dependencies become bound only after other actions
     * have been executed by the sequence.
     *
     * See also `Getter<T>`.
     *
     * @param bindingKey The key of the value we want to eventually get.
     * @param metadata Optional metadata to help the injection
     */
    inject.getter = function injectGetter(bindingKey, metadata) {
        metadata = Object.assign({ decorator: '@inject.getter' }, metadata);
        return inject(bindingKey, metadata, resolveAsGetter);
    };
    /**
     * Inject a function for setting (binding) the given key to a given
     * value. (Only static/constant values are supported, it's not possible
     * to bind a key to a class or a provider.)
     *
     * This is useful e.g. when implementing Actions that are contributing
     * new Elements.
     *
     * See also `Setter<T>`.
     *
     * @param bindingKey The key of the value we want to set.
     * @param metadata Optional metadata to help the injection
     */
    inject.setter = function injectSetter(bindingKey, metadata) {
        metadata = Object.assign({ decorator: '@inject.setter' }, metadata);
        return inject(bindingKey, metadata, resolveAsSetter);
    };
    /**
     * Inject an array of values by a tag pattern string or regexp
     *
     * @example
     * ```ts
     * class AuthenticationManager {
     *   constructor(
     *     @inject.tag('authentication.strategy') public strategies: Strategy[],
     *   ) {}
     * }
     * ```
     * @param bindingTag Tag name or regex
     * @param metadata Optional metadata to help the injection
     */
    inject.tag = function injectTag(bindingTag, metadata) {
        metadata = Object.assign({ decorator: '@inject.tag', tag: bindingTag }, metadata);
        return inject('', metadata, resolveByTag);
    };
    /**
     * Inject the context object.
     *
     * @example
     * ```ts
     * class MyProvider {
     *  constructor(@inject.context() private ctx: Context) {}
     * }
     * ```
     */
    inject.context = function injectContext() {
        return inject('', { decorator: '@inject.context' }, ctx => ctx);
    };
})(inject = exports.inject || (exports.inject = {}));
function resolveAsGetter(ctx, injection, session) {
    // We need to clone the session for the getter as it will be resolved later
    session = resolution_session_1.ResolutionSession.fork(session);
    return function getter() {
        return ctx.get(injection.bindingKey, {
            session,
            optional: injection.metadata && injection.metadata.optional,
        });
    };
}
function resolveAsSetter(ctx, injection) {
    // No resolution session should be propagated into the setter
    return function setter(value) {
        ctx.bind(injection.bindingKey).to(value);
    };
}
/**
 * Return an array of injection objects for parameters
 * @param target The target class for constructor or static methods,
 * or the prototype for instance methods
 * @param method Method name, undefined for constructor
 */
function describeInjectedArguments(target, method) {
    method = method || '';
    const options = {};
    if (method === '') {
        // A hacky way to check if an explicit constructor exists
        // See https://github.com/strongloop/loopback-next/issues/1565
        if (target.toString().match(/\s+constructor\s*\([^\)]*\)\s+\{/m)) {
            options.ownMetadataOnly = true;
        }
    }
    else if (target.hasOwnProperty(method)) {
        // The method exists in the target, no injections on the super method
        // should be honored
        options.ownMetadataOnly = true;
    }
    const meta = metadata_1.MetadataInspector.getAllParameterMetadata(PARAMETERS_KEY, target, method, options);
    return meta || [];
}
exports.describeInjectedArguments = describeInjectedArguments;
function resolveByTag(ctx, injection, session) {
    const tag = injection.metadata.tag;
    const bindings = ctx.findByTag(tag);
    return value_promise_1.resolveList(bindings, b => {
        // We need to clone the session so that resolution of multiple bindings
        // can be tracked in parallel
        return b.getValue(ctx, resolution_session_1.ResolutionSession.fork(session));
    });
}
/**
 * Return a map of injection objects for properties
 * @param target The target class for static properties or
 * prototype for instance properties.
 */
function describeInjectedProperties(target) {
    const metadata = metadata_1.MetadataInspector.getAllPropertyMetadata(PROPERTIES_KEY, target) || {};
    return metadata;
}
exports.describeInjectedProperties = describeInjectedProperties;
//# sourceMappingURL=inject.js.map