"use strict";
// Copyright IBM Corp. 2017,2018. All Rights Reserved.
// Node module: @loopback/context
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const debugModule = require("debug");
const uuid_1 = require("uuid");
const binding_1 = require("./binding");
const binding_key_1 = require("./binding-key");
const resolution_session_1 = require("./resolution-session");
const value_promise_1 = require("./value-promise");
const binding_filter_1 = require("./binding-filter");
const debug = debugModule('loopback:context');
/**
 * Context provides an implementation of Inversion of Control (IoC) container
 */
class Context {
    /**
     * Create a new context
     * @param _parent The optional parent context
     */
    constructor(_parent, name) {
        /**
         * Key to binding map as the internal registry
         */
        this.registry = new Map();
        if (typeof _parent === 'string') {
            name = _parent;
            _parent = undefined;
        }
        this._parent = _parent;
        this.name = name || uuid_1.v1();
    }
    /**
     * Create a binding with the given key in the context. If a locked binding
     * already exists with the same key, an error will be thrown.
     *
     * @param key Binding key
     */
    bind(key) {
        const binding = new binding_1.Binding(key.toString());
        this.add(binding);
        return binding;
    }
    /**
     * Add a binding to the context. If a locked binding already exists with the
     * same key, an error will be thrown.
     * @param binding The configured binding to be added
     */
    add(binding) {
        const key = binding.key;
        /* istanbul ignore if */
        if (debug.enabled) {
            debug('Adding binding: %s', key);
        }
        const keyExists = this.registry.has(key);
        if (keyExists) {
            const existingBinding = this.registry.get(key);
            const bindingIsLocked = existingBinding && existingBinding.isLocked;
            if (bindingIsLocked)
                throw new Error(`Cannot rebind key "${key}" to a locked binding`);
        }
        this.registry.set(key, binding);
        return this;
    }
    /**
     * Unbind a binding from the context. No parent contexts will be checked. If
     * you need to unbind a binding owned by a parent context, use the code below:
     * ```ts
     * const ownerCtx = ctx.getOwnerContext(key);
     * return ownerCtx != null && ownerCtx.unbind(key);
     * ```
     * @param key Binding key
     * @returns true if the binding key is found and removed from this context
     */
    unbind(key) {
        key = binding_key_1.BindingKey.validate(key);
        const binding = this.registry.get(key);
        if (binding == null)
            return false;
        if (binding && binding.isLocked)
            throw new Error(`Cannot unbind key "${key}" of a locked binding`);
        return this.registry.delete(key);
    }
    /**
     * Check if a binding exists with the given key in the local context without
     * delegating to the parent context
     * @param key Binding key
     */
    contains(key) {
        key = binding_key_1.BindingKey.validate(key);
        return this.registry.has(key);
    }
    /**
     * Check if a key is bound in the context or its ancestors
     * @param key Binding key
     */
    isBound(key) {
        if (this.contains(key))
            return true;
        if (this._parent) {
            return this._parent.isBound(key);
        }
        return false;
    }
    /**
     * Get the owning context for a binding key
     * @param key Binding key
     */
    getOwnerContext(key) {
        if (this.contains(key))
            return this;
        if (this._parent) {
            return this._parent.getOwnerContext(key);
        }
        return undefined;
    }
    /**
     * Find bindings using the key pattern
     * @param pattern A filter function, a regexp or a wildcard pattern with
     * optional `*` and `?`. Find returns such bindings where the key matches
     * the provided pattern.
     *
     * For a wildcard:
     * - `*` matches zero or more characters except `.` and `:`
     * - `?` matches exactly one character except `.` and `:`
     *
     * For a filter function:
     * - return `true` to include the binding in the results
     * - return `false` to exclude it.
     */
    find(pattern) {
        const bindings = [];
        const filter = binding_filter_1.filterByKey(pattern);
        for (const b of this.registry.values()) {
            if (filter(b))
                bindings.push(b);
        }
        const parentBindings = this._parent && this._parent.find(filter);
        return this._mergeWithParent(bindings, parentBindings);
    }
    /**
     * Find bindings using the tag filter. If the filter matches one of the
     * binding tags, the binding is included.
     *
     * @param tagFilter  A filter for tags. It can be in one of the following
     * forms:
     * - A regular expression, such as `/controller/`
     * - A wildcard pattern string with optional `*` and `?`, such as `'con*'`
     *   For a wildcard:
     *   - `*` matches zero or more characters except `.` and `:`
     *   - `?` matches exactly one character except `.` and `:`
     * - An object containing tag name/value pairs, such as
     * `{name: 'my-controller'}`
     */
    findByTag(tagFilter) {
        return this.find(binding_filter_1.filterByTag(tagFilter));
    }
    _mergeWithParent(childList, parentList) {
        if (!parentList)
            return childList;
        const additions = parentList.filter(parentBinding => {
            // children bindings take precedence
            return !childList.some(childBinding => childBinding.key === parentBinding.key);
        });
        return childList.concat(additions);
    }
    // Implementation
    async get(keyWithPath, optionsOrSession) {
        /* istanbul ignore if */
        if (debug.enabled) {
            debug('Resolving binding: %s', keyWithPath);
        }
        return await this.getValueOrPromise(keyWithPath, optionsOrSession);
    }
    // Implementation
    getSync(keyWithPath, optionsOrSession) {
        /* istanbul ignore if */
        if (debug.enabled) {
            debug('Resolving binding synchronously: %s', keyWithPath);
        }
        const valueOrPromise = this.getValueOrPromise(keyWithPath, optionsOrSession);
        if (value_promise_1.isPromiseLike(valueOrPromise)) {
            throw new Error(`Cannot get ${keyWithPath} synchronously: the value is a promise`);
        }
        return valueOrPromise;
    }
    getBinding(key, options) {
        key = binding_key_1.BindingKey.validate(key);
        const binding = this.registry.get(key);
        if (binding) {
            return binding;
        }
        if (this._parent) {
            return this._parent.getBinding(key, options);
        }
        if (options && options.optional)
            return undefined;
        throw new Error(`The key ${key} was not bound to any value.`);
    }
    /**
     * Get the value bound to the given key.
     *
     * This is an internal version that preserves the dual sync/async result
     * of `Binding#getValue()`. Users should use `get()` or `getSync()` instead.
     *
     * @example
     *
     * ```ts
     * // get the value bound to "application.instance"
     * ctx.getValueOrPromise<Application>('application.instance');
     *
     * // get "rest" property from the value bound to "config"
     * ctx.getValueOrPromise<RestComponentConfig>('config#rest');
     *
     * // get "a" property of "numbers" property from the value bound to "data"
     * ctx.bind('data').to({numbers: {a: 1, b: 2}, port: 3000});
     * ctx.getValueOrPromise<number>('data#numbers.a');
     * ```
     *
     * @param keyWithPath The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * @param optionsOrSession Options for resolution or a session
     * @returns The bound value or a promise of the bound value, depending
     *   on how the binding was configured.
     * @internal
     */
    getValueOrPromise(keyWithPath, optionsOrSession) {
        const { key, propertyPath } = binding_key_1.BindingKey.parseKeyWithPath(keyWithPath);
        // backwards compatibility
        if (optionsOrSession instanceof resolution_session_1.ResolutionSession) {
            optionsOrSession = { session: optionsOrSession };
        }
        const binding = this.getBinding(key, optionsOrSession);
        if (binding == null)
            return undefined;
        const boundValue = binding.getValue(this, optionsOrSession && optionsOrSession.session);
        if (propertyPath === undefined || propertyPath === '') {
            return boundValue;
        }
        if (value_promise_1.isPromiseLike(boundValue)) {
            return boundValue.then(v => value_promise_1.getDeepProperty(v, propertyPath));
        }
        return value_promise_1.getDeepProperty(boundValue, propertyPath);
    }
    /**
     * Create a plain JSON object for the context
     */
    toJSON() {
        const json = {};
        for (const [k, v] of this.registry) {
            json[k] = v.toJSON();
        }
        return json;
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map