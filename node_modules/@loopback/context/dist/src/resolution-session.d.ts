import { Binding } from './binding';
import { Injection } from './inject';
import { ValueOrPromise, BoundValue } from './value-promise';
import { BindingKey } from './binding-key';
/**
 * A function to be executed with the resolution session
 */
export declare type ResolutionAction = (session?: ResolutionSession) => ValueOrPromise<BoundValue>;
/**
 * Wrapper for bindings tracked by resolution sessions
 */
export interface BindingElement {
    type: 'binding';
    value: Readonly<Binding>;
}
/**
 * Wrapper for injections tracked by resolution sessions
 */
export interface InjectionElement {
    type: 'injection';
    value: Readonly<Injection>;
}
/**
 * Binding or injection elements tracked by resolution sessions
 */
export declare type ResolutionElement = BindingElement | InjectionElement;
/**
 * Object to keep states for a session to resolve bindings and their
 * dependencies within a context
 */
export declare class ResolutionSession {
    /**
     * A stack of bindings for the current resolution session. It's used to track
     * the path of dependency resolution and detect circular dependencies.
     */
    readonly stack: ResolutionElement[];
    /**
     * Fork the current session so that a new one with the same stack can be used
     * in parallel or future resolutions, such as multiple method arguments,
     * multiple properties, or a getter function
     * @param session The current session
     */
    static fork(session?: ResolutionSession): ResolutionSession | undefined;
    /**
     * Start to resolve a binding within the session
     * @param binding The current binding
     * @param session The current resolution session
     */
    private static enterBinding;
    /**
     * Run the given action with the given binding and session
     * @param action A function to do some work with the resolution session
     * @param binding The current binding
     * @param session The current resolution session
     */
    static runWithBinding(action: ResolutionAction, binding: Readonly<Binding>, session?: ResolutionSession): any;
    /**
     * Push an injection into the session
     * @param injection The current injection
     * @param session The current resolution session
     */
    private static enterInjection;
    /**
     * Run the given action with the given injection and session
     * @param action A function to do some work with the resolution session
     * @param binding The current injection
     * @param session The current resolution session
     */
    static runWithInjection(action: ResolutionAction, injection: Readonly<Injection>, session?: ResolutionSession): any;
    /**
     * Describe the injection for debugging purpose
     * @param injection Injection object
     */
    static describeInjection(injection?: Readonly<Injection>): {
        targetName: string;
        bindingKey: string | BindingKey<any>;
        metadata: Object;
    } | undefined;
    /**
     * Push the injection onto the session
     * @param injection Injection The current injection
     */
    pushInjection(injection: Readonly<Injection>): void;
    /**
     * Pop the last injection
     */
    popInjection(): Readonly<Injection<any>>;
    /**
     * Getter for the current injection
     */
    readonly currentInjection: Readonly<Injection> | undefined;
    /**
     * Getter for the current binding
     */
    readonly currentBinding: Readonly<Binding> | undefined;
    /**
     * Enter the resolution of the given binding. If
     * @param binding Binding
     */
    pushBinding(binding: Readonly<Binding>): void;
    /**
     * Exit the resolution of a binding
     */
    popBinding(): Readonly<Binding>;
    /**
     * Getter for bindings on the stack
     */
    readonly bindingStack: Readonly<Binding>[];
    /**
     * Getter for injections on the stack
     */
    readonly injectionStack: Readonly<Injection>[];
    /**
     * Get the binding path as `bindingA --> bindingB --> bindingC`.
     */
    getBindingPath(): string;
    /**
     * Get the injection path as `injectionA --> injectionB --> injectionC`.
     */
    getInjectionPath(): string;
    private static describe;
    /**
     * Get the resolution path including bindings and injections, for example:
     * `bindingA --> @ClassA[0] --> bindingB --> @ClassB.prototype.prop1
     * --> bindingC`.
     */
    getResolutionPath(): string;
}
/**
 * Options for binding/dependency resolution
 */
export interface ResolutionOptions {
    /**
     * A session to track bindings and injections
     */
    session?: ResolutionSession;
    /**
     * A boolean flag to indicate if the dependency is optional. If it's set to
     * `true` and the binding is not bound in a context, the resolution
     * will return `undefined` instead of throwing an error.
     */
    optional?: boolean;
}
