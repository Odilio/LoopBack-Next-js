import { Context } from './context';
import { BoundValue, Constructor, ValueOrPromise, MapObject } from './value-promise';
import { ResolutionSession } from './resolution-session';
/**
 * Create an instance of a class which constructor has arguments
 * decorated with `@inject`.
 *
 * The function returns a class when all dependencies were
 * resolved synchronously, or a Promise otherwise.
 *
 * @param ctor The class constructor to call.
 * @param ctx The context containing values for `@inject` resolution
 * @param session Optional session for binding and dependency resolution
 * @param nonInjectedArgs Optional array of args for non-injected parameters
 */
export declare function instantiateClass<T>(ctor: Constructor<T>, ctx: Context, session?: ResolutionSession, nonInjectedArgs?: any[]): ValueOrPromise<T>;
/**
 * Given a function with arguments decorated with `@inject`,
 * return the list of arguments resolved using the values
 * bound in `ctx`.

 * The function returns an argument array when all dependencies were
 * resolved synchronously, or a Promise otherwise.
 *
 * @param target The class for constructor injection or prototype for method
 * injection
 * @param method The method name. If set to '', the constructor will
 * be used.
 * @param ctx The context containing values for `@inject` resolution
 * @param session Optional session for binding and dependency resolution
 * @param nonInjectedArgs Optional array of args for non-injected parameters
 */
export declare function resolveInjectedArguments(target: Object, method: string, ctx: Context, session?: ResolutionSession, nonInjectedArgs?: any[]): ValueOrPromise<BoundValue[]>;
/**
 * Invoke an instance method with dependency injection
 * @param target Target of the method, it will be the class for a static
 * method, and instance or class prototype for a prototype method
 * @param method Name of the method
 * @param ctx Context
 * @param nonInjectedArgs Optional array of args for non-injected parameters
 */
export declare function invokeMethod(target: Object, method: string, ctx: Context, nonInjectedArgs?: any[]): ValueOrPromise<BoundValue>;
/**
 * Given a class with properties decorated with `@inject`,
 * return the map of properties resolved using the values
 * bound in `ctx`.

 * The function returns an argument array when all dependencies were
 * resolved synchronously, or a Promise otherwise.
 *
 * @param constructor The class for which properties should be resolved.
 * @param ctx The context containing values for `@inject` resolution
 * @param session Optional session for binding and dependency resolution
 */
export declare function resolveInjectedProperties(constructor: Function, ctx: Context, session?: ResolutionSession): ValueOrPromise<MapObject<BoundValue>>;
