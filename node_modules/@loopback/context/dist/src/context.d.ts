import { ValueOrPromise } from '.';
import { Binding, BindingTag } from './binding';
import { BindingAddress } from './binding-key';
import { ResolutionOptions, ResolutionSession } from './resolution-session';
import { BoundValue } from './value-promise';
import { BindingFilter } from './binding-filter';
/**
 * Context provides an implementation of Inversion of Control (IoC) container
 */
export declare class Context {
    /**
     * Name of the context
     */
    readonly name: string;
    /**
     * Key to binding map as the internal registry
     */
    protected readonly registry: Map<string, Binding>;
    /**
     * Parent context
     */
    protected _parent?: Context;
    /**
     * Create a new context
     * @param _parent The optional parent context
     */
    constructor(_parent?: Context | string, name?: string);
    /**
     * Create a binding with the given key in the context. If a locked binding
     * already exists with the same key, an error will be thrown.
     *
     * @param key Binding key
     */
    bind<ValueType = BoundValue>(key: BindingAddress<ValueType>): Binding<ValueType>;
    /**
     * Add a binding to the context. If a locked binding already exists with the
     * same key, an error will be thrown.
     * @param binding The configured binding to be added
     */
    add(binding: Binding<unknown>): this;
    /**
     * Unbind a binding from the context. No parent contexts will be checked. If
     * you need to unbind a binding owned by a parent context, use the code below:
     * ```ts
     * const ownerCtx = ctx.getOwnerContext(key);
     * return ownerCtx != null && ownerCtx.unbind(key);
     * ```
     * @param key Binding key
     * @returns true if the binding key is found and removed from this context
     */
    unbind(key: BindingAddress): boolean;
    /**
     * Check if a binding exists with the given key in the local context without
     * delegating to the parent context
     * @param key Binding key
     */
    contains(key: BindingAddress): boolean;
    /**
     * Check if a key is bound in the context or its ancestors
     * @param key Binding key
     */
    isBound(key: BindingAddress): boolean;
    /**
     * Get the owning context for a binding key
     * @param key Binding key
     */
    getOwnerContext(key: BindingAddress): Context | undefined;
    /**
     * Find bindings using the key pattern
     * @param pattern A filter function, a regexp or a wildcard pattern with
     * optional `*` and `?`. Find returns such bindings where the key matches
     * the provided pattern.
     *
     * For a wildcard:
     * - `*` matches zero or more characters except `.` and `:`
     * - `?` matches exactly one character except `.` and `:`
     *
     * For a filter function:
     * - return `true` to include the binding in the results
     * - return `false` to exclude it.
     */
    find<ValueType = BoundValue>(pattern?: string | RegExp | BindingFilter): Readonly<Binding<ValueType>>[];
    /**
     * Find bindings using the tag filter. If the filter matches one of the
     * binding tags, the binding is included.
     *
     * @param tagFilter  A filter for tags. It can be in one of the following
     * forms:
     * - A regular expression, such as `/controller/`
     * - A wildcard pattern string with optional `*` and `?`, such as `'con*'`
     *   For a wildcard:
     *   - `*` matches zero or more characters except `.` and `:`
     *   - `?` matches exactly one character except `.` and `:`
     * - An object containing tag name/value pairs, such as
     * `{name: 'my-controller'}`
     */
    findByTag<ValueType = BoundValue>(tagFilter: BindingTag | RegExp): Readonly<Binding<ValueType>>[];
    protected _mergeWithParent<ValueType>(childList: Readonly<Binding<ValueType>>[], parentList?: Readonly<Binding<ValueType>>[]): Readonly<Binding<ValueType>>[];
    /**
     * Get the value bound to the given key, throw an error when no value was
     * bound for the given key.
     *
     * @example
     *
     * ```ts
     * // get the value bound to "application.instance"
     * const app = await ctx.get<Application>('application.instance');
     *
     * // get "rest" property from the value bound to "config"
     * const config = await ctx.get<RestComponentConfig>('config#rest');
     *
     * // get "a" property of "numbers" property from the value bound to "data"
     * ctx.bind('data').to({numbers: {a: 1, b: 2}, port: 3000});
     * const a = await ctx.get<number>('data#numbers.a');
     * ```
     *
     * @param keyWithPath The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * @returns A promise of the bound value.
     */
    get<ValueType>(keyWithPath: BindingAddress<ValueType>): Promise<ValueType>;
    /**
     * Get the value bound to the given key, optionally return a (deep) property
     * of the bound value.
     *
     * @example
     *
     * ```ts
     * // get "rest" property from the value bound to "config"
     * // use "undefined" when not config was provided
     * const config = await ctx.get<RestComponentConfig>('config#rest', {
     *   optional: true
     * });
     * ```
     *
     * @param keyWithPath The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * @param optionsOrSession Options or session for resolution. An instance of
     * `ResolutionSession` is accepted for backward compatibility.
     * @returns A promise of the bound value, or a promise of undefined when
     * the optional binding was not found.
     */
    get<ValueType>(keyWithPath: BindingAddress<ValueType>, optionsOrSession?: ResolutionOptions | ResolutionSession): Promise<ValueType | undefined>;
    /**
     * Get the synchronous value bound to the given key, optionally
     * return a (deep) property of the bound value.
     *
     * This method throws an error if the bound value requires async computation
     * (returns a promise). You should never rely on sync bindings in production
     * code.
     *
     * @example
     *
     * ```ts
     * // get the value bound to "application.instance"
     * const app = ctx.getSync<Application>('application.instance');
     *
     * // get "rest" property from the value bound to "config"
     * const config = await ctx.getSync<RestComponentConfig>('config#rest');
     * ```
     *
     * @param keyWithPath The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * * @param optionsOrSession Options or session for resolution. An instance of
     * `ResolutionSession` is accepted for backward compatibility.
     * @returns A promise of the bound value.
     */
    getSync<ValueType>(keyWithPath: BindingAddress<ValueType>): ValueType;
    /**
     * Get the synchronous value bound to the given key, optionally
     * return a (deep) property of the bound value.
     *
     * This method throws an error if the bound value requires async computation
     * (returns a promise). You should never rely on sync bindings in production
     * code.
     *
     * @example
     *
     * ```ts
     * // get "rest" property from the value bound to "config"
     * // use "undefined" when no config was provided
     * const config = await ctx.getSync<RestComponentConfig>('config#rest', {
     *   optional: true
     * });
     * ```
     *
     * @param keyWithPath The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * * @param optionsOrSession Options or session for resolution. An instance of
     * `ResolutionSession` is accepted for backward compatibility.
     * @returns The bound value, or undefined when an optional binding was not found.
     */
    getSync<ValueType>(keyWithPath: BindingAddress<ValueType>, optionsOrSession?: ResolutionOptions | ResolutionSession): ValueType | undefined;
    /**
     * Look up a binding by key in the context and its ancestors. If no matching
     * binding is found, an error will be thrown.
     *
     * @param key Binding key
     */
    getBinding<ValueType = BoundValue>(key: BindingAddress<ValueType>): Binding<ValueType>;
    /**
     * Look up a binding by key in the context and its ancestors. If no matching
     * binding is found and `options.optional` is not set to true, an error will
     * be thrown.
     *
     * @param key Binding key
     * @param options Options to control if the binding is optional. If
     * `options.optional` is set to true, the method will return `undefined`
     * instead of throwing an error if the binding key is not found.
     */
    getBinding<ValueType>(key: BindingAddress<ValueType>, options?: {
        optional?: boolean;
    }): Binding<ValueType> | undefined;
    /**
     * Get the value bound to the given key.
     *
     * This is an internal version that preserves the dual sync/async result
     * of `Binding#getValue()`. Users should use `get()` or `getSync()` instead.
     *
     * @example
     *
     * ```ts
     * // get the value bound to "application.instance"
     * ctx.getValueOrPromise<Application>('application.instance');
     *
     * // get "rest" property from the value bound to "config"
     * ctx.getValueOrPromise<RestComponentConfig>('config#rest');
     *
     * // get "a" property of "numbers" property from the value bound to "data"
     * ctx.bind('data').to({numbers: {a: 1, b: 2}, port: 3000});
     * ctx.getValueOrPromise<number>('data#numbers.a');
     * ```
     *
     * @param keyWithPath The binding key, optionally suffixed with a path to the
     *   (deeply) nested property to retrieve.
     * @param optionsOrSession Options for resolution or a session
     * @returns The bound value or a promise of the bound value, depending
     *   on how the binding was configured.
     * @internal
     */
    getValueOrPromise<ValueType>(keyWithPath: BindingAddress<ValueType>, optionsOrSession?: ResolutionOptions | ResolutionSession): ValueOrPromise<ValueType | undefined>;
    /**
     * Create a plain JSON object for the context
     */
    toJSON(): Object;
}
